// __multiversion__

#ifndef BYPASS_PIXEL_SHADER

#if __VERSION__ >= 300
	#ifdef MSAA_FRAMEBUFFER_ENABLED
		centroid out vec2 uv0;
		centroid out vec2 uv1;
	#else
		out vec2 uv0;
		out vec2 uv1;
	#endif

	#define attribute in
	#define varying out
#else
	varying vec2 uv0;
	varying vec2 uv1;
#endif

	varying vec4 color;
	varying vec4 mistColor;

#ifdef SEASONS
	varying vec3 sCol;
#endif

#ifdef FOG
	varying lowp float wetRefl;
#endif

#if defined(BLEND) || defined(FAR_BLEND)
	#define MAYBE_WATER
	varying lowp float water;
#endif

#endif

#include "uniformWorldConstants.h"
#include "uniformPerFrameConstants.h"
#include "uniformShaderConstants.h"
#include "uniformRenderChunkConstants.h"

#include "utilities/detectors.glsl"
#include "config_utilities/sky.h"
#include "config_utilities/mist_fog.h"
#include "config_utilities/clouds.h"
#include "config_utilities/global.h"
#include "config_utilities/terrain.h"

uniform highp float TOTAL_REAL_WORLD_TIME;

attribute POS4 POSITION;
attribute vec4 COLOR;
attribute vec2 TEXCOORD_0;
attribute vec2 TEXCOORD_1;

const float rd = 1.57079;
const float shadowIntensity = 1.0-shadow_intensity;

bool is(float val,float val1,float val2){
	return (val>val1 && val<val2);
}

float noise1D(float x){
	return cos(x)*cos(x*3.0)*cos(x*5.0) + 1.0;
}

float fastRand(vec2 n){ 
	float a = cos( dot(n,vec2(4.2683,1.367)) );
	float b = dot( n,vec2(1.367,4.683) );
	return fract(a+b);
}

float disp(vec3 pos, highp float t, bool chunkBorder){
	if(chunkBorder){
		return 0.5 + sin(t + (pos.x+pos.z)*rd )*0.5;
	}
	else{
		float val = 0.5 + 0.5*sin(t*1.7+((pos.x+pos.y)*rd));
		return mix(fastRand(pos.xz),fastRand(pos.xz+vec2(1.0)),val);
	}
}

vec3 getSkyRefl(vec3 horizonEdge, vec3 horizon, vec3 zenith, float y, float h){

	float offset = h/(50.0+h);
	y = max((y-offset)/(1.0-offset),0.0);

	return renderSky(horizonEdge, horizon, zenith, y);
}

vec3 getRainSkyRefl(vec3 horizon, vec3 zenith, float h){

	h = 1.0-h*h;
	float hsq = h*h;

	return mix(zenith,horizon,hsq*hsq);
}

float calculateFresnel(float cosR){
	float a = 1.0-cosR;

	float a5 = a*a;
	a5 *= a5*a;

	return 0.03 + 0.97*a5;
}

void main()
{
	POS4 worldPos;
	POS4 pos;

#ifdef AS_ENTITY_RENDERER
	pos = WORLDVIEWPROJ * POSITION;
	worldPos = pos;
#else
	worldPos.xyz = ((POSITION.xyz) * CHUNK_ORIGIN_AND_SCALE.w) + CHUNK_ORIGIN_AND_SCALE.xyz;
	worldPos.w = 1.0;
#endif

	vec3 wPos = worldPos.xyz;
	vec3 cPos = POSITION.xyz;

#ifndef BYPASS_PIXEL_SHADER

	uv0 = TEXCOORD_0;
	uv1 = TEXCOORD_1;
	color = COLOR;

	vec2 lit = uv1*uv1;

	bool isColored = (color.g > min(color.r,color.b)) || !(color.r==color.g && color.r==color.b);

	bool chunkBorder = (fract(cPos.x*0.0625)*fract(cPos.z*0.0625) == 0.0);

	lowp float shade = color.g;
	if(isColored){shade *= 1.5;}

	bool end = detectEnd();
	bool nether = detectNether();

	#ifdef FOG
		bool underWater = detectUnderwater();
		float rainFactor = detectRain(underWater);
	#else
		bool underWater = false;
		float rainFactor = 0.0;
	#endif

	#ifdef MAYBE_WATER
		bool isWater = COLOR.b>COLOR.r;
		water = float(isWater);
	#else
		bool isWater = false;
	#endif

	vec3 zenithCol = getZenithCol(rainFactor);
	vec3 horizonCol = getHorizonCol(rainFactor);
	vec3 horizonEdgeCol = getHorizonEdgeCol(horizonCol,rainFactor);
	if(underWater){
		vec3 fogcol = getUnderwaterCol();
		zenithCol = fogcol;
		horizonCol = fogcol;
		horizonEdgeCol = fogcol;
	}

#ifdef USE_REAL_WORLD_TIME
	highp float t = 1980.0 - 0.55*abs(TOTAL_REAL_WORLD_TIME*2.0-3600.0);
#else
	highp float t = TIME;
#endif


#ifdef SEASONS
	sCol = COLOR.rgb;
	color.rgb = vec3(1.0);

	uv1.y *= 1.00151;
#else
	if(isColored){color.rgb *= color.rgb*1.2;}

	if(color.a<0.005 || (fract(cPos.y)==0.5 && fract(cPos.x)==0.0) ){uv1.y *= 1.00151;}
#endif

float torch_attenuation = (torch_intensity*uv1.x)/(0.5-0.45*lit.x);

#ifdef BLINKING_TORCH
	torch_attenuation *= 1.0 - 0.1*noise1D(t*2.5);
#endif

vec3 torchLight = torch_color*torch_attenuation;

vec3 light;
if(nether || end){
	if(end){
		light = vec3(1.98,1.25,2.3);
	}else{
		light = vec3(1.98,1.44,1.26);
	}

	light += torchLight*1.1;
}
else{
	float dayFactor = min(dot(FOG_COLOR.rgb,vec3(0.5,0.4,0.4))*(1.0 + 1.9*rainFactor),1.0);
	float nightFactor = 1.0-dayFactor*dayFactor;
	float rainDim = min(FOG_COLOR.g,0.25)*rainFactor;
	float lightIntensity = sun_intensity*(1.0 - rainDim)*(1.0 + night_brightness*nightFactor);

	light = vec3(1.35*(1.0-uv1.x)*(1.0-uv1.y));

	light += mix(horizonCol,zenithCol,0.5+uv1.y-0.5*lit.y)*(lit.y*(3.0-2.0*uv1.y)*(1.3 + (4.0*nightFactor) - rainDim));

	float shadow = float(uv1.y > 0.876);

	#ifdef REMOVE_OLD_SHADOW
		if(uv1.y < 0.876 && uv1.x>0.0){shadow = uv1.y;}
	#endif

	shadow += (0.2+0.3*rainFactor)*(1.0-shadow)*float(uv1.y > 0.85);

	shadow = max(shadow,(shadowIntensity + (0.6*shadow_intensity*nightFactor))*lit.y);
	shadow *= 0.8 + 0.2*float(shade>0.8);

	float dirLight = shadow*(1.0-uv1.x*nightFactor)*lightIntensity;
	light += dirLight*sunLightTint(night_color,morning_color,noon_color,dayFactor,rainFactor);

	light += vec3(0.3*lit.y*uv1.y*(1.2-shadow)*lightIntensity);

	light += torchLight*(1.0-(max(shadow,0.65*lit.y)*dayFactor*(1.0-0.3*rainFactor)));
}

light *= 0.8+0.2*float(COLOR.g>0.35);

if(color.a<0.005){light *= 1.3;}

lowp float distanceThreshold = abs(wPos.x)+abs(wPos.y)+abs(wPos.z);

#ifdef ALPHA_TEST

	vec3 bPos = fract(cPos.xyz);

	vec2 texMap = uv0*vec2(64.0,32.0);
	vec2 texNo = ceil(texMap);
	float texPosY = fract(texMap.y);

	#ifdef PLANTS_WAVE

	#ifdef SEASONS
		bool shouldWave = true;
	#else

	bool isTop = texPosY < 0.5 || (texNo.y==6.0 && (texNo.x==12.0||texNo.x==13.0));
	bool isTreeLeaves = COLOR.a==0.0 && max(COLOR.g,COLOR.r)>0.37;
	bool isPlants = (COLOR.r/COLOR.g<1.9);
	bool isVines = bPos.y==0.0 && (bPos.x==0.046875 || is(bPos.z,0.0468,0.06) || bPos.x==0.953125 || bPos.z==0.953125);
	bool isFarmPlant = (bPos.y==0.9375) && any( equal(bPos.xzxz,vec4(0.25,0.25,0.75,0.75)) ); 
	bool shouldWave = ((isTreeLeaves || isPlants || isVines) && isColored) || (isFarmPlant && isTop);

	light *= 1.0 - 0.35*float(isFarmPlant && !isTop);
	if(isColored && !isTreeLeaves && texNo.y==13.0){
		light *= 1.2 - (0.5+(1.0-bPos.y)*float(bPos.y >0.0))*float(!isTop);
	}

	#endif

	if(shouldWave && distanceThreshold<40.0){

		float phaseDiff = dot(cPos.xyz,vec3(0.7854)) + disp(cPos.xyz,t,chunkBorder);

		float amplitude = PLANTS_WAVE;
		amplitude *= noise1D(t*0.15) + (rainFactor*0.4);

		#ifdef SEASONS
			amplitude *= 0.5;
		#else

			amplitude *= 1.0 - 0.5*float(isTreeLeaves);
			amplitude *= 1.0 - (0.6 + 0.3*float(isTop))*float(isVines);

			if(isPlants && isColored && !isTop){amplitude *= (bPos.y-1.0)*float(bPos.y>0.0);}

		#endif

		float wave = 1.0+mix(
			sin(t*wave_speed*(1.0-0.5*float(underWater)) + phaseDiff),
			sin(t*wave_speed*1.5 + phaseDiff),
			rainFactor);
		wave *= amplitude*uv1.y;

		worldPos.y -= wave*wave*0.5;
		worldPos.xz -= vec2(wave);

	}

	#endif
	#ifdef LANTERN_WAVE

		bool y6875 = bPos.y==0.6875;
		bool y5625 = bPos.y==0.5625;

		bool isLantern = ( (y6875 || y5625) && (bPos.x==0.375 || bPos.x==0.625) ) || ( (y5625 || bPos.y==0.125) && (bPos.x==0.3125 || bPos.x==0.6875) );
		bool isChain = (bPos.x==0.4375 || bPos.x==0.5625) && y6875;

		if( texPosY<0.3 || is(texPosY,0.67,0.69) || is(texPosY,0.55,0.6) ){
			isLantern = isLantern && !y5625;
		}

		if( (isChain||isLantern) && uv1.x>0.6){
			float offset = dot(floor(cPos),vec3(0.3927));

			float theta = sin(t + offset) + rainFactor*sin(t*1.4 + offset);
			theta *= LANTERN_WAVE*lit.y*noise1D(t*0.15);

			float sinA = sin(theta);
			float cosA = 1.0-cos(theta);

			vec2 pivotPos = vec2(0.5,1.0)-bPos.xy;

			worldPos.x += pivotPos.x*cosA - pivotPos.y*sinA;
			worldPos.y += pivotPos.y*cosA + pivotPos.x*sinA;
		}

	#endif

#else

	#if defined(MAYBE_WATER) && defined(WATER_WAVE)
		if(isWater && distanceThreshold < 35.0){
			worldPos.y += 0.002;
			worldPos.xy += WATER_WAVE*vec2(1.0,min(15.0*fract(cPos.y),1.5))*sin( t*2.0 + dot(cPos.xyz,vec3(rd)));
		}
	#endif

#endif

#endif


#ifndef AS_ENTITY_RENDERER
	pos = WORLDVIEW * worldPos;
	pos = PROJ * pos;
#endif

	gl_Position = pos;


#ifndef BYPASS_PIXEL_SHADER


#ifdef FANCY
	float camDist = length(wPos.xyz);
#else
	float camDist = pos.x/(1.0+pos.z);
	camDist = (1.0 + camDist*camDist)*pos.z;
#endif

float relativeDist = camDist / RENDER_DISTANCE;


#ifdef BLEND
	if(color.a < 0.95) {
		#ifdef FANCY
			float alphaFadeOut = clamp(camDist / FAR_CHUNKS_DISTANCE, 0.0, 1.0);
			color.a = color.a + (1.0-color.a)*water_opacity;
			color.a = mix(color.a,1.0,alphaFadeOut);
		#else
			color.a = 1.0;
		#endif
	}
#endif


mistColor = renderMist(horizonEdgeCol, relativeDist, lit.x, rainFactor, nether,underWater,end);

if(!nether && !underWater){
	mistColor.rgb *= max(0.75,uv1.y);
	mistColor.rgb += torch_color*torch_intensity*lit.x*0.3;
}


#if defined(FOG) || defined(BLEND)

#ifdef FANCY
	vec3 viewDir = -wPos.xyz/camDist;
#else
	vec3 viewDir = normalize(-wPos.xyz);
#endif

#ifdef MAYBE_WATER
if(isWater){  
	float fractCposY = fract(cPos.y);

	vec3 transmission = color.rgb*water_tint*3.1;

	transmission *= 0.3 + (FOG_COLOR.g*(2.0-2.0*FOG_COLOR.g)*rainFactor);
	transmission *= light*max(max(FOG_COLOR.b,0.2+lit.x),FOG_COLOR.r*1.2)*max(0.3+0.7*uv1.y,uv1.x);

	float cosR;
	vec3 waterRefl;

	if( fractCposY > 0.0 ){

		cosR = abs(viewDir.y);

		waterRefl = getSkyRefl(horizonEdgeCol,horizonCol,zenithCol,cosR,-wPos.y);

		if(uv1.y < 0.93 && !end){waterRefl *= 0.7*uv1.y;}

		waterRefl += vec3(0.02*(1.0-uv1.y)) + torch_color*torch_intensity*(0.6*float(uv1.x>0.83));

		if( is(fractCposY,0.8,0.9) ){ waterRefl *= 1.0 - 0.66*clamp(wPos.y,0.0,1.0); }

		else{ waterRefl *= (0.4+0.1*sin(t*2.0+cPos.y*12.566)) - 0.2*float(fractCposY > 0.9); }
	}

	else{
		cosR = max(sqrt(dot(viewDir.xz,viewDir.xz)),float(wPos.y<0.5));

		waterRefl = zenithCol*(lit.y*1.3);
	}

	float fresnel = calculateFresnel(cosR);

	float opacity = 1.0-cosR;
	color.a = color.a + (1.0-color.a)*opacity*opacity;

	color.rgb = transmission*(1.0-0.4*fresnel) + 1.2*waterRefl*fresnel;

}
#endif

#endif

#ifdef FOG

#ifdef UNDERWATER

	#ifdef UNDERWATER_WAVE
		gl_Position.xy += vec2(UNDERWATER_WAVE*min(0.05*pos.z,0.6)*sin(t*1.2 + dot(cPos,vec3(rd))));
	#endif

	if(uv1.y < 0.9){
		vec3 underWaterColor = mix(underwater_color,vec3(1.0),lit.y*0.7);

		light = underWaterColor*(light*0.7 + vec3(underwater_brightness));

		float caustics = disp(cPos.xyz*vec3(1.0,0.1,1.0), t, chunkBorder);
		caustics += 0.25+0.25*sin(t + (cPos.x + cPos.z)*rd);

		caustics *= 1.6 + 1.6*float( any(lessThan(abs(uv1.yyyy-vec4(0.815,0.685,0.565,0.435)),vec4(0.05))) || is(uv1.y,0.31,0.32));

		light += caustics*underWaterColor*(0.1+lit.y+(lit.x*0.7))*caustic_intensity;

		mistColor.rgb = (1.0+lit.y*0.6)*mix(mistColor.rgb,torch_color*torch_intensity*underwater_color,lit.x);
		mistColor.a += (1.0-mistColor.a)*dot(lit,vec2(0.2));
	}

#endif

float fogGradient = 1.0-max(-viewDir.y+0.1,0.0);
fogGradient = 1.0-fogGradient*fogGradient*fogGradient;

wetRefl = 0.0;
if(rainFactor > 0.0){

	mistColor.a *= 1.0-rainFactor*fogGradient;

	float endDist = RENDER_DISTANCE*0.6;

	bool topSurface = shade>0.9;
	#ifdef ALPHA_TEST
	topSurface = topSurface && color.a<0.001;
	#endif

	if(!isWater && topSurface && camDist < endDist){

		float wetness;
		if(chunkBorder){ wetness = max(0.5+0.5*sin((cPos.x+cPos.z)*rd),0.6);}
		else{ wetness = min(0.4+0.6*fastRand(cPos.xz*1.4),1.0);}
		wetness *= lit.y*lit.y;

		float cosR = max(viewDir.y,float(wPos.y > 0.0));

		wetRefl = horizonCol.b*(1.0-0.7*cosR);
		wetRefl *= calculateFresnel(cosR)*rainFactor*wetness;

		wetRefl *= 1.0-clamp( (2.0*camDist/endDist)-1.0 ,0.0 ,1.0 );
		color.rgb *= 1.0-0.5*wetness*rainFactor;
	}
	else{
		color.rgb *= 1.0-0.4*lit.y*lit.y*rainFactor;
	}

}

	#ifdef ALLOW_FADE
		relativeDist += RENDER_CHUNK_FOG_ALPHA;
	#endif

	vec4 fogColor = renderFog(horizonEdgeCol, relativeDist, nether);

	if(nether){
		fogColor.rgb = mix(fogColor.rgb,vec3(0.8,0.2,0.12)*1.5,lit.x*(1.67-fogColor.a*1.67));
	}
	else{
		if(end){fogColor.rgb = vec3(0.16,0.06,0.2);}
		if(!underWater){fogColor.a *= 1.0-fogGradient;}
	}

	mistColor.a = min(mistColor.a + fogColor.a*(1.0-mistColor.a),1.0);
	mistColor.rgb = mix(mistColor.rgb,fogColor.rgb,fogColor.a);

#endif

#ifdef MAYBE_WATER
	if(!isWater){ color.rgb *= light; }
#else
	color.rgb *= light;
#endif

#endif

}
